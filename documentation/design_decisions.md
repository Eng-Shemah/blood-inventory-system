# Design Decisions â€“ Smart Blood Inventory Management System

## 1. Overview
This document explains the key architectural, database, and PL/SQL design decisions made during the development of the **Smart Blood Inventory Management System**. The goal of the system is to ensure reliable blood availability, minimize wastage, support decision-making through Business Intelligence (BI), and demonstrate advanced PL/SQL concepts required for the practicum.

---

## 2. Database Design Decisions

### 2.1 Normalized Relational Model
The database follows **Third Normal Form (3NF)** to:
- Eliminate redundancy
- Improve data integrity
- Simplify maintenance

Core entities such as `DONORS`, `BLOOD_UNITS`, `PATIENTS`, and `TRANSFUSIONS` are separated and connected using foreign keys.

Decision Rationale:  
Normalized tables allow accurate reporting and efficient BI analytics without duplication of data.

---

### 2.2 Use of Surrogate Primary Keys
Each table uses a **numeric surrogate primary key** generated by sequences (e.g., `SEQ_DONORS`, `SEQ_BLOOD_UNITS`).

Decision Rationale:  
- Faster joins and indexing
- Avoids dependency on business attributes
- Supports future schema changes safely

---

### 2.3 Status-Based Inventory Management
The `BLOOD_UNITS.status` column uses controlled values:
- `AVAILABLE`
- `IN_USE`
- `EXPIRED`
- `DISCARDED`

Decision Rationale:  
This approach enables flexible lifecycle management without deleting critical historical data.

---

## 3. PL/SQL Design Decisions

### 3.1 Modular Procedures and Functions
Business logic is separated into:
- **Procedures** for transactions (INSERT, UPDATE, DELETE)
- **Functions** for calculations, validations, and lookups

Decision Rationale:  
Encapsulation improves reusability, readability, and testability.

---

### 3.2 Parameterized Procedures
All procedures use `IN`, `OUT`, or `IN OUT` parameters.

Decision Rationale:  
- Promotes secure data handling
- Supports reuse by BI tools and application layers
- Enables result tracking and validation

---

### 3.3 Explicit Transaction Control
Critical procedures explicitly use:
- `COMMIT`
- `ROLLBACK`

Decision Rationale:  
Ensures atomicity and consistency for medical data operations such as transfusions and inventory updates.

---

## 4. Exception Handling Strategy

### 4.1 Custom Exceptions
Custom exceptions are defined for:
- Invalid blood types
- Underage donors
- Incompatible transfusions
- Invalid status transitions

Decision Rationale:  
Custom exceptions provide clear, user-friendly error messages and improve debugging.

---

### 4.2 Centralized Error Reporting
All procedures raise errors using a standardized mechanism, for example:

```sql
RAISE_APPLICATION_ERROR(-20001, 'Descriptive error message here');
```

Decision Rationale:  
Standardized error codes simplify troubleshooting and testing.

---

## 5. Performance Optimization Decisions

### 5.1 Explicit Cursors and BULK COLLECT
Explicit cursors are used where multi-row processing is required.  
`BULK COLLECT` is applied for large result sets (e.g., inactive donors).

Decision Rationale:  
Improves performance and demonstrates advanced PL/SQL capabilities.

---

### 5.2 Window Functions for Analytics
The system uses window functions for analytical queries, for example:

```sql
ROW_NUMBER()
RANK()
DENSE_RANK()
LAG() / LEAD()
Aggregates with OVER()
```

Decision Rationale:  
Window functions enable advanced analytics without complex joins, supporting BI dashboards and reports.

---

## 6. Business Intelligence Integration

### 6.1 BI-Friendly Query Design
PL/SQL functions such as:

- `fn_get_inventory_level`
- `fn_get_shortage_risk`

Return scalar values easily consumable by:

- Excel Pivot Tables
- BI dashboards
- Reporting tools

Decision Rationale:  
Simplifies integration with Excel-based BI and supports real-time analytics.

---

### 6.2 Predictive Analytics Approach
Shortage prediction is calculated using:
- Current inventory levels
- Historical transfusion data (30-day window)

Decision Rationale:  
Provides proactive insights while keeping implementation manageable in PL/SQL.

---

## 7. Security and Data Integrity

### 7.1 Data Validation at Database Level
Key validations (age, blood type, compatibility) are enforced in PL/SQL rather than relying on user input.

Decision Rationale:  
Ensures consistent enforcement regardless of application or reporting layer.

---

### 7.2 Audit-Friendly Design
Instead of deleting operational data:
- Status updates are preferred
- Historical records are preserved

Decision Rationale:  
Supports compliance, accountability, and long-term BI analysis.

---

## 8. Testing Strategy

### 8.1 Unit Testing
Each procedure and function is tested independently using SQL Developer scripts.

### 8.2 Edge Case Validation
Edge cases tested include:
- Invalid donor age
- Duplicate emails
- Incompatible blood types
- Expired blood usage

### 8.3 Performance Testing
Bulk operations and window functions are tested on large datasets to ensure acceptable execution times.

---

## 9. Alignment with Practicum Requirements
This design fully satisfies the practicum requirements by incorporating:
- 5+ procedures
- 5+ functions
- Explicit cursors and bulk operations
- Window functions
- Packages
- BI integration
- Robust exception handling

---

## 10. Conclusion
The design decisions made in this project ensure a scalable, secure, and BI-ready blood inventory system. The architecture balances real-world applicability with academic requirements, showcasing strong mastery of PL/SQL, database design, and analytical reporting.

Author: [Your Name]  
Date: 2025-11-16